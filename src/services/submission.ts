import * as vscode from "vscode"

import { WebviewPanelRegistry } from "@/providers/problem-webview/panel-registry"
import { Problem, SubmissionStatus, VSCodeToWebviewCommand } from "@/types"
import { StaticLogger, waitMilliseconds } from "@/utils"
import { readFile } from "fs/promises"
import { basename } from "path"
import { FileService } from "./file"
import { JutgeService } from "./jutge"
import { proglangInfoGet, proglangFromFilepath } from "./runners/languages"

export type Veredict = {
    problem_nm: string
    status: SubmissionStatus
}

const info_ = (msg: string) => {
    console.log("[SubmissionService]:", msg)
}

export class SubmissionService extends StaticLogger {
    private static MONITOR_INTERVAL_MS = 5000

    private static emitter_: vscode.EventEmitter<Veredict> =
        new vscode.EventEmitter<Veredict>()

    // This member is for VSCode, so that we can signal changes in the tree
    static readonly onDidReceiveVeredict: vscode.Event<Veredict> = this.emitter_.event

    /**
     * Submits the currently open file to Jutge.
     * Before submitting, it runs all testcases to ensure correctness.
     *
     * @param problem The problem to which the file is being submitted.
     * @param filePath Path to the file being submitted
     *
     * In this function, we will assume that the file was generated by the extension,
     * from where we can get the compiler_id (by looking at the first four commented lines).
     * If that is not available, we can try with the default compiler for a certain extension.
     */
    public static async submitProblem(problem: Problem, filePath: string): Promise<void> {
        vscode.window.withProgress(
            {
                location: vscode.ProgressLocation.Notification,
                title: `Submitting ${problem.problem_nm}`,
                cancellable: false,
            },
            async (progress) => {
                const { problem_nm, problem_id } = problem
                this.log.info(
                    `Preparing to submit problem ${problem_id} from file ${filePath}`
                )

                const proglang = proglangFromFilepath(filePath)
                const langInfo = proglangInfoGet(proglang)

                const header = await FileService.parseFileHeader(filePath)
                let compiler_id = header.compiler_id || langInfo.compilers[0]
                this.log.debug(`Using compiler ID: ${compiler_id}`)

                progress.report({ message: "Submitting..." })
                this._sendStatusUpdate(problem_nm, SubmissionStatus.PENDING)

                const nowDate = new Date().toLocaleDateString()
                const nowTime = new Date().toLocaleTimeString()

                try {
                    this.log.debug(`Reading file content`)
                    const code = await readFile(filePath)
                    const file = new File([code], basename(filePath), {
                        type: langInfo.mimeType,
                    })

                    this.log.info(`Submitting to Jutge.org`)
                    const { submission_id } = await JutgeService.submit(file, {
                        problem_id,
                        compiler_id,
                        annotation: `Sent through VSCode on ${nowDate} at ${nowTime}`,
                    })

                    this.log.info(`Submission successful (${submission_id})`)
                    progress.report({
                        message: `Submission successful (${submission_id})`,
                    })

                    const verdict = await this._waitForVerdictLoop(
                        problem,
                        submission_id,
                        progress
                    )

                    this._showVerdictNotification(problem, submission_id, verdict)

                    info_(
                        `Emitting onDidReceiveVeredict (${problem.problem_nm}, ${verdict})`
                    )
                    this.emitter_.fire({
                        problem_nm: problem.problem_nm,
                        status: verdict,
                    })
                    //
                } catch (err) {
                    this.log.error(`Error submitting to Jutge: ${err}`)
                    vscode.window.showErrorMessage("Error submitting to Jutge: " + err)
                }
            }
        )
    }

    private static async _waitForVerdictLoop(
        problem: Problem,
        submission_id: string,
        progress: vscode.Progress<{
            message?: string
            increment?: number
        }>
    ) {
        const { problem_nm, problem_id } = problem
        let times = 1

        let verdict: SubmissionStatus = SubmissionStatus.PENDING

        while (verdict === SubmissionStatus.PENDING) {
            await waitMilliseconds(this.MONITOR_INTERVAL_MS)
            try {
                const response = await JutgeService.getSubmission({
                    problem_id,
                    submission_id,
                })
                verdict = response.veredict as SubmissionStatus
            } catch (error) {
                vscode.window.showErrorMessage(
                    "Error getting submission status: " + error
                )
            }
            progress.report({ message: `Waiting (${times}) ...` })
            times++
        }

        this._sendStatusUpdate(problem_nm, verdict)
        return verdict
    }

    private static async _showVerdictNotification(
        problem: Problem,
        submission_id: string,
        verdict: string
    ) {
        const text = (verdict && this._verdictText.get(verdict)) || "‚ùì"

        const selection = await vscode.window.showInformationMessage(text, {
            title: "View in jutge.org",
        })
        if (selection && selection.title === "View in jutge.org") {
            const path = `/${problem.problem_id}/submissions/${submission_id}`
            vscode.env.openExternal(vscode.Uri.parse(`https://jutge.org/problems${path}`))
        }
    }

    private static _sendStatusUpdate(problemNm: string, status: SubmissionStatus) {
        WebviewPanelRegistry.sendMessage(problemNm, {
            command: VSCodeToWebviewCommand.UPDATE_SUBMISSION_STATUS,
            data: { status },
        })
    }

    private static _verdictText: Map<string, string> = new Map([
        ["AC", "üü¢ Accepted!"],
        ["WA", "üî¥ Wrong Answer"],
        ["IC", "üö´ Invalid Character"],
        ["PE", "üü° Presentation Error"],
        ["EE", "üí£ Execution Error"],
        ["CE", "üõ† Compilation Error"],
        ["IE", "üî• Internal Error"],
        ["Pending", "‚è≥ Pending..."],
    ])
}
