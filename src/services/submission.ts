import * as vscode from "vscode"

import { StaticLogger } from "@/loggers"
import { WebviewPanelRegistry } from "@/providers/problem-webview/panel-registry"
import { Problem, SubmissionStatus, VSCodeToWebviewCommand } from "@/types"
import { waitMilliseconds } from "@/utils"
import { readFile } from "fs/promises"
import { basename } from "path"
import { FileService } from "./file"
import { JutgeService } from "./jutge"
import { proglangFromFilepath, proglangInfoGet } from "./runners/languages"

export type Veredict = {
    problem_nm: string
    status: SubmissionStatus
}

export class SubmissionService extends StaticLogger {
    private static MONITOR_INTERVAL_MS = 2000

    private static emitter_: vscode.EventEmitter<Veredict> = new vscode.EventEmitter<Veredict>()

    // This member is for VSCode, so that we can signal changes in the tree
    static readonly onDidReceiveVeredict: vscode.Event<Veredict> = this.emitter_.event

    /**
     * Submits the currently open file to Jutge.
     * Before submitting, it runs all testcases to ensure correctness.
     *
     * @param problem The problem to which the file is being submitted.
     * @param filePath Path to the file being submitted
     *
     * In this function, we will assume that the file was generated by the extension,
     * from where we can get the compiler_id (by looking at the first four commented lines).
     * If that is not available, we can try with the default compiler for a certain extension.
     */
    public static async submitProblem(problem: Problem, filePath: string): Promise<void> {
        const result = await vscode.window.withProgress(
            {
                location: vscode.ProgressLocation.Notification,
                title: `Submitting ${problem.problem_nm}`,
                cancellable: false,
            },
            async (progress) => {
                const { problem_nm, problem_id } = problem
                this.log.info(`Preparing to submit problem ${problem_id} from file ${filePath}`)

                const proglang = proglangFromFilepath(filePath)
                const langInfo = proglangInfoGet(proglang)

                const header = await FileService.parseFileHeader(filePath)
                let compiler_id = header.compiler_id || langInfo.compilers[0]
                this.log.debug(`Using compiler ID: ${compiler_id}`)

                progress.report({ message: "Submitting..." })
                this._sendStatusUpdate(problem_nm, SubmissionStatus.PENDING)

                const nowDate = new Date().toLocaleDateString()
                const nowTime = new Date().toLocaleTimeString()

                try {
                    this.log.debug(`Reading file content`)
                    const code = await readFile(filePath)
                    const file = new File([Buffer.from(code)], basename(filePath), {
                        type: langInfo.mimeType,
                    })
                    this.log.debug(`File has ${file.size} bytes`)

                    this.log.info(`Submitting to Jutge.org`)
                    const { submission_id } = await JutgeService.submit(file, {
                        problem_id,
                        compiler_id,
                        annotation: `Sent through VSCode on ${nowDate} at ${nowTime}`,
                    })

                    this.log.info(`Submission successful (${submission_id})`)
                    progress.report({
                        message: `Submission successful (${submission_id})`,
                    })

                    const verdict = await this._waitForVerdictLoop(
                        problem,
                        submission_id,
                        progress
                    )

                    this.emitter_.fire({
                        problem_nm: problem.problem_nm,
                        status: verdict,
                    })

                    return { submission_id, verdict }
                } catch (err) {
                    let message = String(err)
                    if (err instanceof Error) {
                        message = err.message
                        if (err.cause instanceof Error) {
                            message = err.cause.message
                        }
                    }
                    this.log.error(`Error submitting to Jutge: `, message)
                    vscode.window.showErrorMessage(`Error submitting to Jutge: ${message}`)
                    this._sendStatusUpdate(problem_nm, SubmissionStatus.FAILED)
                }
            }
        )
        if (result) {
            this._sendStatusUpdate(problem.problem_nm, result.verdict)
            await this._showVerdictNotification(problem, result.submission_id, result.verdict)
        }
    }

    private static async _waitForVerdictLoop(
        problem: Problem,
        submission_id: string,
        progress: vscode.Progress<{ message?: string; increment?: number }>
    ): Promise<SubmissionStatus> {
        let times = 1
        let verdict: SubmissionStatus = SubmissionStatus.PENDING

        try {
            while (verdict === SubmissionStatus.PENDING) {
                // NOTE(pauek): Wait first so that the last progress report
                // (which was the "submission successful") is visible for a while...
                await waitMilliseconds(this.MONITOR_INTERVAL_MS)

                progress.report({ message: `Waiting (${times++}) ...` })

                const response = await JutgeService.getSubmission({
                    problem_id: problem.problem_id,
                    submission_id,
                })

                verdict = response.veredict as SubmissionStatus
            }
        } catch (error) {
            await vscode.window.showErrorMessage("Error getting submission status: " + error)
            verdict = SubmissionStatus.PENDING
        }

        return verdict
    }

    private static async _showVerdictNotification(
        problem: Problem,
        submission_id: string,
        verdict: string
    ) {
        const text = (verdict && this._verdictText.get(verdict)) || "‚ùì"
        const host = JutgeService.isExamMode() ? "https://exam.jutge.org" : "https://jutge.org"

        const selection = await vscode.window.showInformationMessage(text, {
            title: "View in jutge.org",
        })
        if (selection && selection.title === "View in jutge.org") {
            const path = `/${problem.problem_id}/submissions/${submission_id}`
            vscode.env.openExternal(vscode.Uri.parse(`${host}/problems${path}`))
        }
        // https://exam.jutge.org/problems/P68688_ca/submissions/E007
    }

    private static async _sendStatusUpdate(problemNm: string, status: SubmissionStatus) {
        return WebviewPanelRegistry.sendMessage(problemNm, {
            command: VSCodeToWebviewCommand.UPDATE_SUBMISSION_STATUS,
            data: { status },
        })
    }

    private static _verdictText: Map<string, string> = new Map([
        ["AC", "üü¢ Accepted!"],
        ["WA", "üî¥ Wrong Answer"],
        ["IC", "üö´ Invalid Character"],
        ["PE", "üü° Presentation Error"],
        ["EE", "üí£ Execution Error"],
        ["CE", "üõ† Compilation Error"],
        ["IE", "üî• Internal Error"],
        ["Pending", "‚è≥ Pending..."],
    ])
}
